name "trajectory_generation"

import_types_from "base"
using_library "reflexxes"
import_types_from "trajectory_generationTypes.hpp"

task_context "Task" do
    cycle_time = 0.02

    needs_configuration
    runtime_states 'FOLLOWING', 'REACHED', 'IN_LIMITS'

    property('limits', 'base/JointLimits').
        doc('The limits for the joints')
    property('cycle_time', 'double').
        doc('Cycle time in seconds')
    property('positional_limits_behavior', 'int', 0).
        doc("Behavior when reaching positional limits. Can be one of 0 = RMLFlags::POSITIONAL_LIMITS_IGNORE,1 = RMLFlags::POSITIONAL_LIMITS_ERROR_MSG_ONLY, 2 = RMLFlags::POSITIONAL_LIMITS_ACTIVELY_PREVENT. Only available for Reflexxes Type_IV")
    property('sync_behavior', 'int', 1).
        doc("The synchronization behavior of RML. Can be one of 0 = RMLFlags::PHASE_SYNCHRONIZATION_IF_POSSIBLE, 1 = RMLFlags::ONLY_TIME_SYNCHRONIZATION, 2 = RMLFlags::ONLY_PHASE_SYNCHRONIZATION, 3 = RMLFlags::NO_SYNCHRONIZATION")
    property('max_jerk', 'std/vector<double>').
        doc("Maximum change of acceleration. Size has to be the same as limits")

    property('override_input_position', 'bool', false).
        doc('Set output position as input for next cycle')
    property('override_input_speed', 'bool', false).
        doc('Set output speed as input for next cycle')
    property('treat_effort_as_acceleration', 'bool', false).
        doc('Use the effort field from JointState type for acceleration.')
    property('override_input_acceleration', 'bool', true).
        doc('Set output acceleration as input for next cycle. When treat_effort_as_acceleration == false, input acceleration is always overriden. In this case, acceleration is always assumed to zero at first sample.')

    property('override_output_speed', 'bool', false).
        doc('Override the output speed.')
    property('override_output_effort', 'bool', false).
        doc('Override the output effort.')
    property('override_speed_value', 'double').
        doc('Set output speed to this value every time.')
    property('override_acceleration_value', 'double').
        doc('Set output acceleration to this value every time. If treat_effort_as_acceleration = false, this property has no effect.')

    property('override_target_velocity', 'double').
        doc('Set target velocity forcefully to this value')


    input_port("trajectory_target", "/base/JointsTrajectory").
	doc("The target trajectory which should be followed")
    input_port("position_target", "/base/commands/Joints").
        doc("The target joint position")

    # Forbid certain joints to move in a positive direction
    input_port("dont_allow_positive", "/std/vector<std/string>")

    # Forbid certain joints to move in a negative direction
    input_port("dont_allow_negative", "/std/vector<std/string>")

    input_port("joint_state", "/base/samples/Joints").
	doc("Current state measurement from the actuators")

    output_port("cmd", "/base/commands/Joints").
	doc("Target values that are send to the actuators")

    # Estimated next robot state. Equals the full interpolator output
    output_port("output_sample", "/base/samples/Joints")

    # Debug ports

    output_port("actual_cycle_time", "double")
    output_port("rml_input_params", "trajectory_generation/RMLInputParams")
    output_port("rml_output_params", "trajectory_generation/RMLOutputParams")
    output_port("dist_upper_limit", "base/VectorXd")
    output_port("dist_lower_limit", "base/VectorXd")

    port_driven "joint_state"
end

task_context "RMLVelocityTask" do
    cycle_time = 0.01

    needs_configuration
    runtime_states 'FOLLOWING', 'REACHED', 'IN_LIMITS'

    # The limits for the joints. Note: min.speed and min.effort are not used. Effort limit is used as acceleration limit.
    property('limits', 'base/JointLimits') 

    # Maximum change of acceleration. Size has to be the same as limits
    property('max_jerk', 'std/vector<double>')

    # Cycle time in seconds
    property('cycle_time', 'double') 
  
    # The synchronization behavior of RML. Can be one of 0 = RMLFlags::PHASE_SYNCHRONIZATION_IF_POSSIBLE,
    # 1 = RMLFlags::ONLY_TIME_SYNCHRONIZATION, 2 = RMLFlags::ONLY_PHASE_SYNCHRONIZATION, 3 = RMLFlags::NO_SYNCHRONIZATION
    property('sync_behavior', 'int', 1)
    
    # Behavior when reaching positional limits. Can be one of 0 = RMLFlags::POSITIONAL_LIMITS_IGNORE,
    # 1 = RMLFlags::POSITIONAL_LIMITS_ERROR_MSG_ONLY, 2 = RMLFlags::POSITIONAL_LIMITS_ACTIVELY_PREVENT.
    # Only available for Reflexxes Type_IV
    property('positional_limits_behavior', 'int', 0)

    # Scale all max acceleration values by this factor. Range: 0..1
    property('max_acceleration_scale', 'double', 1.0)

    # If no new command comes in for such a long time, set velocity to zero
    property('timeout', 'double', 0.3)

    # Scale all max jerk values by this factor. Range: 0..1 
    property('max_jerk_scale', 'double', 1.0)

    # Set output position as input for next cycle
    property('override_input_position', 'bool', false)

    # Set output speed as input for next cycle
    property('override_input_speed', 'bool', false)

    # Use the effort field from JointState type for acceleration.
    property('treat_effort_as_acceleration', 'bool', false)
    # Set output acceleration as input for next cycle. When treat_effort_as_acceleration == false, input acceleration is always overriden. In this case, acceleration is always assumed to zero at first sample.
    property('override_input_acceleration', 'bool', false)

  
    # The target joint velocity
    input_port("velocity_target", "/base/commands/Joints")

    # Current state measurement from the actuators
    input_port("joint_state", "/base/samples/Joints")

    # Forbid certain joints to move in a positive direction
    input_port("dont_allow_positive", "/std/vector<std/string>")

    # Forbid certain joints to move in a negative direction
    input_port("dont_allow_negative", "/std/vector<std/string>")

    # Target values that are send to the actuators
    output_port("command", "/base/commands/Joints")

    # Estimated next robot state. Equals the full interpolator output
    output_port("output_sample", "/base/samples/Joints")

    # Debug Port: Current cycle time
    output_port("actual_cycle_time", "double")

    # Debug Port: Input values of the rml algorithm
    output_port("rml_input_params", "trajectory_generation/RMLInputParams")

    # Debug Port: Output values of the rml algorithm
    output_port("rml_output_params", "trajectory_generation/RMLOutputParams")

    # Debug Port: Distance to upper limits
    output_port("dist_upper", "base/VectorXd")

    # Debug Port: Distance to lower limits
    output_port("dist_lower", "base/VectorXd")


    periodic cycle_time
end

task_context "TestPlant" do
   needs_configuration
   property("limits", "/base/JointLimits")
   property("noise_mean", "/base/JointState")
   property("noise_variance", "/base/JointState")
   property("use_fixed_simulation_step_time", "bool")
   property("simulation_step_time", "double").doc("In seconds")
   
   input_port("cmd", "/base/commands/Joints")
   output_port("joint_state", "/base/samples/Joints")
   

   periodic 0.021172983273343216 #That's how fast artemis' joints update
end

deployment "plant_deployment" do
    task 'plant', 'trajectory_generation::TestPlant'
    add_default_logger
end
